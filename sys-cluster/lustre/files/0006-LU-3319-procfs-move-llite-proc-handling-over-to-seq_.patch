From 01ce737ef8bba37c904d79f3aabe88a4ead20b74 Mon Sep 17 00:00:00 2001
From: James Simmons <uja.ornl@gmail.com>
Date: Thu, 5 Dec 2013 13:53:37 -0500
Subject: [PATCH 06/18] LU-3319 procfs: move llite proc handling over to
 seq_file

For lustre clients a special abstract layer so a lustre
client can be mounted. In order to support 3.10+ kernels
this client code being the llite,vvp,and clio layers proc
proc handling has been ported to using seq_files only.

Signed-off-by: James Simmons <uja.ornl@gmail.com>
Change-Id: Id2ac0956dbdf586ab1200e2edb00d489c15c5d50
---
 lustre/include/cl_object.h    |   4 +-
 lustre/include/lu_object.h    |   1 +
 lustre/llite/llite_internal.h |   7 +-
 lustre/llite/llite_lib.c      |  40 ++-
 lustre/llite/lproc_llite.c    | 611 +++++++++++++++++++++---------------------
 lustre/llite/super25.c        |   2 +-
 lustre/llite/vvp_dev.c        |   7 +-
 lustre/obdclass/cl_object.c   |  93 +++----
 lustre/obdclass/lu_object.c   |  22 ++
 9 files changed, 402 insertions(+), 385 deletions(-)

diff --git a/lustre/include/cl_object.h b/lustre/include/cl_object.h
index 0aedd62..9735671 100644
--- a/lustre/include/cl_object.h
+++ b/lustre/include/cl_object.h
@@ -2553,8 +2553,6 @@ struct cache_stats {
 
 /** These are not exported so far */
 void cache_stats_init (struct cache_stats *cs, const char *name);
-int  cache_stats_print(const struct cache_stats *cs,
-                       char *page, int count, int header);
 
 /**
  * Client-side site. This represents particular client stack. "Global"
@@ -2586,7 +2584,7 @@ void cl_stack_fini(const struct lu_env *env, struct cl_device *cl);
  * Output client site statistical counters into a buffer. Suitable for
  * ll_rd_*()-style functions.
  */
-int cl_site_stats_print(const struct cl_site *s, char *page, int count);
+int cl_site_stats_print(const struct cl_site *site, struct seq_file *m);
 
 /**
  * \name helpers
diff --git a/lustre/include/lu_object.h b/lustre/include/lu_object.h
index 94c0b47..103debd 100644
--- a/lustre/include/lu_object.h
+++ b/lustre/include/lu_object.h
@@ -1279,6 +1279,7 @@ int  lu_env_refill_by_tags(struct lu_env *env, __u32 ctags, __u32 stags);
  * Output site statistical counters into a buffer. Suitable for
  * ll_rd_*()-style functions.
  */
+int lu_site_stats_seq_print(const struct lu_site *s, struct seq_file *m);
 int lu_site_stats_print(const struct lu_site *s, char *page, int count);
 
 /**
diff --git a/lustre/llite/llite_internal.h b/lustre/llite/llite_internal.h
index 283e106..44f6522 100644
--- a/lustre/llite/llite_internal.h
+++ b/lustre/llite/llite_internal.h
@@ -706,15 +706,16 @@ int lprocfs_register_mountpoint(struct proc_dir_entry *parent,
                                 struct super_block *sb, char *osc, char *mdc);
 void lprocfs_unregister_mountpoint(struct ll_sb_info *sbi);
 void ll_stats_ops_tally(struct ll_sb_info *sbi, int op, int count);
-void lprocfs_llite_init_vars(struct lprocfs_static_vars *lvars);
+int ll_process_proc_param(struct lustre_cfg *lcfg, unsigned long *sb);
 #else
 static inline int lprocfs_register_mountpoint(struct proc_dir_entry *parent,
                         struct super_block *sb, char *osc, char *mdc){return 0;}
 static inline void lprocfs_unregister_mountpoint(struct ll_sb_info *sbi) {}
 static void ll_stats_ops_tally(struct ll_sb_info *sbi, int op, int count) {}
-static void lprocfs_llite_init_vars(struct lprocfs_static_vars *lvars)
+
+static int ll_process_proc_param(struct lustre_cfg *lcfg, unsigned long *sb)
 {
-        memset(lvars, 0, sizeof(*lvars));
+	return 0;
 }
 #endif
 
diff --git a/lustre/llite/llite_lib.c b/lustre/llite/llite_lib.c
index 9d9e432..86f07c9 100644
--- a/lustre/llite/llite_lib.c
+++ b/lustre/llite/llite_lib.c
@@ -2277,31 +2277,23 @@ out_statfs:
 
 int ll_process_config(struct lustre_cfg *lcfg)
 {
-        char *ptr;
-        void *sb;
-        struct lprocfs_static_vars lvars;
-        unsigned long x;
-        int rc = 0;
+	struct super_block *sb;
+	unsigned long x;
+	char *ptr;
 
-        lprocfs_llite_init_vars(&lvars);
-
-        /* The instance name contains the sb: lustre-client-aacfe000 */
-        ptr = strrchr(lustre_cfg_string(lcfg, 0), '-');
-        if (!ptr || !*(++ptr))
-                return -EINVAL;
-        if (sscanf(ptr, "%lx", &x) != 1)
-                return -EINVAL;
-        sb = (void *)x;
-        /* This better be a real Lustre superblock! */
-        LASSERT(s2lsi((struct super_block *)sb)->lsi_lmd->lmd_magic == LMD_MAGIC);
-
-        /* Note we have not called client_common_fill_super yet, so
-           proc fns must be able to handle that! */
-        rc = class_process_proc_param(PARAM_LLITE, lvars.obd_vars,
-                                      lcfg, sb);
-        if (rc > 0)
-                rc = 0;
-        return(rc);
+	/* The instance name contains the sb: lustre-client-aacfe000 */
+	ptr = strrchr(lustre_cfg_string(lcfg, 0), '-');
+	if (!ptr || !*(++ptr))
+		return -EINVAL;
+	if (sscanf(ptr, "%lx", &x) != 1)
+		return -EINVAL;
+	sb = (struct super_block *)x;
+	/* This better be a real Lustre superblock! */
+	LASSERT(s2lsi(sb)->lsi_lmd->lmd_magic == LMD_MAGIC);
+
+	/* Note we have not called client_common_fill_super yet, so
+	   proc fns must be able to handle that! */
+	return ll_process_proc_param(lcfg, &x);
 }
 
 /* this function prepares md_op_data hint for passing ot down to MD stack. */
diff --git a/lustre/llite/lproc_llite.c b/lustre/llite/lproc_llite.c
index 2686924..7793a63 100644
--- a/lustre/llite/lproc_llite.c
+++ b/lustre/llite/lproc_llite.c
@@ -37,8 +37,8 @@
 
 #include <linux/version.h>
 #include <lustre_lite.h>
+#include <lustre_param.h>
 #include <lprocfs_status.h>
-#include <linux/seq_file.h>
 #include <obd_support.h>
 
 #include "llite_internal.h"
@@ -52,10 +52,9 @@ struct file_operations ll_rw_extents_stats_fops;
 struct file_operations ll_rw_extents_stats_pp_fops;
 struct file_operations ll_rw_offset_stats_fops;
 
-static int ll_rd_blksize(char *page, char **start, off_t off, int count,
-                         int *eof, void *data)
+static int ll_blksize_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = (struct super_block *)data;
+	struct super_block *sb = m->private;
         struct obd_statfs osfs;
         int rc;
 
@@ -63,18 +62,15 @@ static int ll_rd_blksize(char *page, char **start, off_t off, int count,
         rc = ll_statfs_internal(sb, &osfs,
                                 cfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),
                                 OBD_STATFS_NODELAY);
-        if (!rc) {
-              *eof = 1;
-              rc = snprintf(page, count, "%u\n", osfs.os_bsize);
-        }
-
+	if (!rc)
+		rc = seq_printf(m, "%u\n", osfs.os_bsize);
         return rc;
 }
+LPROC_SEQ_FOPS_RO(ll_blksize);
 
-static int ll_rd_kbytestotal(char *page, char **start, off_t off, int count,
-                             int *eof, void *data)
+static int ll_kbytestotal_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = (struct super_block *)data;
+	struct super_block *sb = m->private;
         struct obd_statfs osfs;
         int rc;
 
@@ -89,17 +85,15 @@ static int ll_rd_kbytestotal(char *page, char **start, off_t off, int count,
                 while (blk_size >>= 1)
                         result <<= 1;
 
-                *eof = 1;
-                rc = snprintf(page, count, LPU64"\n", result);
+		rc = seq_printf(m, LPU64"\n", result);
         }
         return rc;
-
 }
+LPROC_SEQ_FOPS_RO(ll_kbytestotal);
 
-static int ll_rd_kbytesfree(char *page, char **start, off_t off, int count,
-                            int *eof, void *data)
+static int ll_kbytesfree_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = (struct super_block *)data;
+	struct super_block *sb = m->private;
         struct obd_statfs osfs;
         int rc;
 
@@ -114,16 +108,15 @@ static int ll_rd_kbytesfree(char *page, char **start, off_t off, int count,
                 while (blk_size >>= 1)
                         result <<= 1;
 
-                *eof = 1;
-                rc = snprintf(page, count, LPU64"\n", result);
+		rc = seq_printf(m, LPU64"\n", result);
         }
         return rc;
 }
+LPROC_SEQ_FOPS_RO(ll_kbytesfree);
 
-static int ll_rd_kbytesavail(char *page, char **start, off_t off, int count,
-                             int *eof, void *data)
+static int ll_kbytesavail_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = (struct super_block *)data;
+	struct super_block *sb = m->private;
         struct obd_statfs osfs;
         int rc;
 
@@ -138,16 +131,15 @@ static int ll_rd_kbytesavail(char *page, char **start, off_t off, int count,
                 while (blk_size >>= 1)
                         result <<= 1;
 
-                *eof = 1;
-                rc = snprintf(page, count, LPU64"\n", result);
+		rc = seq_printf(m, LPU64"\n", result);
         }
         return rc;
 }
+LPROC_SEQ_FOPS_RO(ll_kbytesavail);
 
-static int ll_rd_filestotal(char *page, char **start, off_t off, int count,
-                            int *eof, void *data)
+static int ll_filestotal_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = (struct super_block *)data;
+	struct super_block *sb = m->private;
         struct obd_statfs osfs;
         int rc;
 
@@ -155,86 +147,73 @@ static int ll_rd_filestotal(char *page, char **start, off_t off, int count,
         rc = ll_statfs_internal(sb, &osfs,
                                 cfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),
                                 OBD_STATFS_NODELAY);
-        if (!rc) {
-                 *eof = 1;
-                 rc = snprintf(page, count, LPU64"\n", osfs.os_files);
-        }
-        return rc;
+	if (!rc)
+		rc = seq_printf(m, LPU64"\n", osfs.os_files);
+	return rc;
 }
+LPROC_SEQ_FOPS_RO(ll_filestotal);
 
-static int ll_rd_filesfree(char *page, char **start, off_t off, int count,
-                           int *eof, void *data)
+static int ll_filesfree_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = (struct super_block *)data;
-        struct obd_statfs osfs;
-        int rc;
-
-        LASSERT(sb != NULL);
-        rc = ll_statfs_internal(sb, &osfs,
-                                cfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),
-                                OBD_STATFS_NODELAY);
-        if (!rc) {
-                 *eof = 1;
-                 rc = snprintf(page, count, LPU64"\n", osfs.os_ffree);
-        }
-        return rc;
+	struct super_block *sb = m->private;
+	struct obd_statfs osfs;
+	int rc;
 
+	LASSERT(sb != NULL);
+	rc = ll_statfs_internal(sb, &osfs,
+				cfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),
+				OBD_STATFS_NODELAY);
+	if (!rc)
+		rc = seq_printf(m, LPU64"\n", osfs.os_ffree);
+	return rc;
 }
+LPROC_SEQ_FOPS_RO(ll_filesfree);
 
-static int ll_rd_client_type(char *page, char **start, off_t off, int count,
-                            int *eof, void *data)
+static int ll_client_type_seq_show(struct seq_file *m, void *v)
 {
-        struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)data);
-        int rc;
-
-        LASSERT(sbi != NULL);
+	struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);
+	int rc;
 
-        *eof = 1;
-        if (sbi->ll_flags & LL_SBI_RMT_CLIENT)
-                rc = snprintf(page, count, "remote client\n");
-        else
-                rc = snprintf(page, count, "local client\n");
+	LASSERT(sbi != NULL);
 
-        return rc;
+	if (sbi->ll_flags & LL_SBI_RMT_CLIENT)
+		rc = seq_printf(m, "remote client\n");
+	else
+		rc = seq_printf(m, "local client\n");
+	return rc;
 }
+LPROC_SEQ_FOPS_RO(ll_client_type);
 
-static int ll_rd_fstype(char *page, char **start, off_t off, int count,
-                        int *eof, void *data)
+static int ll_fstype_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = (struct super_block*)data;
+	struct super_block *sb = m->private;
 
-        LASSERT(sb != NULL);
-        *eof = 1;
-        return snprintf(page, count, "%s\n", sb->s_type->name);
+	LASSERT(sb != NULL);
+	return seq_printf(m, "%s\n", sb->s_type->name);
 }
+LPROC_SEQ_FOPS_RO(ll_fstype);
 
-static int ll_rd_sb_uuid(char *page, char **start, off_t off, int count,
-                         int *eof, void *data)
+static int ll_sb_uuid_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = (struct super_block *)data;
+	struct super_block *sb = m->private;
 
-        LASSERT(sb != NULL);
-        *eof = 1;
-        return snprintf(page, count, "%s\n", ll_s2sbi(sb)->ll_sb_uuid.uuid);
+	LASSERT(sb != NULL);
+	return seq_printf(m, "%s\n", ll_s2sbi(sb)->ll_sb_uuid.uuid);
 }
+LPROC_SEQ_FOPS_RO(ll_sb_uuid);
 
-static int ll_rd_xattr_cache(char *page, char **start, off_t off,
-				int count, int *eof, void *data)
+static int ll_xattr_cache_seq_show(struct seq_file *m, void *v)
 {
-	struct super_block *sb = (struct super_block *)data;
-	struct ll_sb_info *sbi = ll_s2sbi(sb);
-	int rc;
-
-	rc = snprintf(page, count, "%u\n", sbi->ll_xattr_cache_enabled);
+	struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);
 
-	return rc;
+	return seq_printf(m, "%u\n", sbi->ll_xattr_cache_enabled);
 }
 
-static int ll_wr_xattr_cache(struct file *file, const char *buffer,
-				unsigned long count, void *data)
+static ssize_t ll_xattr_cache_seq_write(struct file *file, const char *buffer,
+					size_t count, loff_t *off)
 {
-	struct super_block *sb = (struct super_block *)data;
-	struct ll_sb_info *sbi = ll_s2sbi(sb);
+	struct seq_file *m = file->private_data;
+	struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);
 	int val, rc;
 
 	rc = lprocfs_write_helper(buffer, count, &val);
@@ -251,24 +230,23 @@ static int ll_wr_xattr_cache(struct file *file, const char *buffer,
 
 	return count;
 }
+LPROC_SEQ_FOPS(ll_xattr_cache);
 
-static int ll_rd_site_stats(char *page, char **start, off_t off,
-                            int count, int *eof, void *data)
+static int ll_site_stats_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = data;
-
-        /*
-         * See description of statistical counters in struct cl_site, and
-         * struct lu_site.
-         */
-        return cl_site_stats_print(lu2cl_site(ll_s2sbi(sb)->ll_site),
-                                   page, count);
+	struct super_block *sb = m->private;
+
+	/*
+	 * See description of statistical counters in struct cl_site, and
+	 * struct lu_site.
+	 */
+	return cl_site_stats_print(lu2cl_site(ll_s2sbi(sb)->ll_site), m);
 }
+LPROC_SEQ_FOPS_RO(ll_site_stats);
 
-static int ll_rd_max_readahead_mb(char *page, char **start, off_t off,
-                                   int count, int *eof, void *data)
+static int ll_max_readahead_mb_seq_show(struct seq_file *m, void *v)
 {
-	struct super_block *sb = data;
+	struct super_block *sb = m->private;
 	struct ll_sb_info *sbi = ll_s2sbi(sb);
 	long pages_number;
 	int mult;
@@ -278,14 +256,15 @@ static int ll_rd_max_readahead_mb(char *page, char **start, off_t off,
 	spin_unlock(&sbi->ll_lock);
 
 	mult = 1 << (20 - PAGE_CACHE_SHIFT);
-	return lprocfs_read_frac_helper(page, count, pages_number, mult);
+	return lprocfs_seq_read_frac_helper(m, pages_number, mult);
 }
 
-static int ll_wr_max_readahead_mb(struct file *file, const char *buffer,
-				  unsigned long count, void *data)
+static ssize_t
+ll_max_readahead_mb_seq_write(struct file *file, const char *buffer,
+			      size_t count, loff_t *off)
 {
-	struct super_block *sb = data;
-	struct ll_sb_info *sbi = ll_s2sbi(sb);
+	struct seq_file *m = file->private_data;
+	struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);
 	int mult, rc, pages_number;
 
 	mult = 1 << (20 - PAGE_CACHE_SHIFT);
@@ -303,14 +282,13 @@ static int ll_wr_max_readahead_mb(struct file *file, const char *buffer,
 	spin_lock(&sbi->ll_lock);
 	sbi->ll_ra_info.ra_max_pages = pages_number;
 	spin_unlock(&sbi->ll_lock);
-
 	return count;
 }
+LPROC_SEQ_FOPS(ll_max_readahead_mb);
 
-static int ll_rd_max_readahead_per_file_mb(char *page, char **start, off_t off,
-                                           int count, int *eof, void *data)
+static int ll_max_readahead_per_file_mb_seq_show(struct seq_file *m, void *v)
 {
-	struct super_block *sb = data;
+	struct super_block *sb = m->private;
 	struct ll_sb_info *sbi = ll_s2sbi(sb);
 	long pages_number;
 	int mult;
@@ -320,15 +298,16 @@ static int ll_rd_max_readahead_per_file_mb(char *page, char **start, off_t off,
 	spin_unlock(&sbi->ll_lock);
 
 	mult = 1 << (20 - PAGE_CACHE_SHIFT);
-	return lprocfs_read_frac_helper(page, count, pages_number, mult);
+	return lprocfs_seq_read_frac_helper(m, pages_number, mult);
 }
 
-static int ll_wr_max_readahead_per_file_mb(struct file *file, const char *buffer,
-                                          unsigned long count, void *data)
+static ssize_t
+ll_max_readahead_per_file_mb_seq_write(struct file *file, const char *buffer,
+				       size_t count, loff_t *off)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
-        int mult, rc, pages_number;
+	struct seq_file *m = file->private_data;
+	struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);
+	int mult, rc, pages_number;
 
 	mult = 1 << (20 - PAGE_CACHE_SHIFT);
         rc = lprocfs_write_frac_helper(buffer, count, &pages_number, mult);
@@ -346,14 +325,13 @@ static int ll_wr_max_readahead_per_file_mb(struct file *file, const char *buffer
 	spin_lock(&sbi->ll_lock);
 	sbi->ll_ra_info.ra_max_pages_per_file = pages_number;
 	spin_unlock(&sbi->ll_lock);
-
 	return count;
 }
+LPROC_SEQ_FOPS(ll_max_readahead_per_file_mb);
 
-static int ll_rd_max_read_ahead_whole_mb(char *page, char **start, off_t off,
-                                         int count, int *eof, void *data)
+static int ll_max_read_ahead_whole_mb_seq_show(struct seq_file *m, void *v)
 {
-	struct super_block *sb = data;
+	struct super_block *sb = m->private;
 	struct ll_sb_info *sbi = ll_s2sbi(sb);
 	long pages_number;
 	int mult;
@@ -363,14 +341,15 @@ static int ll_rd_max_read_ahead_whole_mb(char *page, char **start, off_t off,
 	spin_unlock(&sbi->ll_lock);
 
 	mult = 1 << (20 - PAGE_CACHE_SHIFT);
-	return lprocfs_read_frac_helper(page, count, pages_number, mult);
+	return lprocfs_seq_read_frac_helper(m, pages_number, mult);
 }
 
-static int ll_wr_max_read_ahead_whole_mb(struct file *file, const char *buffer,
-					 unsigned long count, void *data)
+static ssize_t
+ll_max_read_ahead_whole_mb_seq_write(struct file *file, const char *buffer,
+				     size_t count, loff_t *off)
 {
-	struct super_block *sb = data;
-	struct ll_sb_info *sbi = ll_s2sbi(sb);
+	struct seq_file *m = file->private_data;
+	struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);
 	int mult, rc, pages_number;
 
 	mult = 1 << (20 - PAGE_CACHE_SHIFT);
@@ -392,24 +371,22 @@ static int ll_wr_max_read_ahead_whole_mb(struct file *file, const char *buffer,
 	spin_lock(&sbi->ll_lock);
 	sbi->ll_ra_info.ra_max_read_ahead_whole_pages = pages_number;
 	spin_unlock(&sbi->ll_lock);
-
 	return count;
 }
+LPROC_SEQ_FOPS(ll_max_read_ahead_whole_mb);
 
-static int ll_rd_max_cached_mb(char *page, char **start, off_t off,
-                               int count, int *eof, void *data)
+static int ll_max_cached_mb_seq_show(struct seq_file *m, void *v)
 {
-	struct super_block     *sb    = data;
+	struct super_block     *sb    = m->private;
 	struct ll_sb_info      *sbi   = ll_s2sbi(sb);
 	struct cl_client_cache *cache = &sbi->ll_cache;
 	int shift = 20 - PAGE_CACHE_SHIFT;
 	int max_cached_mb;
 	int unused_mb;
 
-	*eof = 1;
 	max_cached_mb = cache->ccc_lru_max >> shift;
 	unused_mb = cfs_atomic_read(&cache->ccc_lru_left) >> shift;
-	return snprintf(page, count,
+	return seq_printf(m,
 			"users: %d\n"
 			"max_cached_mb: %d\n"
 			"used_mb: %d\n"
@@ -422,16 +399,17 @@ static int ll_rd_max_cached_mb(char *page, char **start, off_t off,
 			cache->ccc_lru_shrinkers);
 }
 
-static int ll_wr_max_cached_mb(struct file *file, const char *buffer,
-				unsigned long nob, void *data)
+static ssize_t
+ll_max_cached_mb_seq_write(struct file *file, const char *buffer,
+			   size_t count, loff_t *off)
 {
-	struct super_block *sb = data;
+	struct seq_file *m = file->private_data;
+	struct super_block *sb = m->private;
 	struct ll_sb_info *sbi = ll_s2sbi(sb);
 	struct cl_client_cache *cache = &sbi->ll_cache;
 	struct lu_env *env;
 	int refcheck;
 	int mult, rc, pages_number;
-	size_t count = nob;
 	int diff = 0;
 	int nrpages = 0;
 	ENTRY;
@@ -512,22 +490,21 @@ out:
 	}
 	return rc;
 }
+LPROC_SEQ_FOPS(ll_max_cached_mb);
 
-static int ll_rd_checksum(char *page, char **start, off_t off,
-                          int count, int *eof, void *data)
+static int ll_checksum_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
+	struct super_block *sb = m->private;
+	struct ll_sb_info *sbi = ll_s2sbi(sb);
 
-        return snprintf(page, count, "%u\n",
-                        (sbi->ll_flags & LL_SBI_CHECKSUM) ? 1 : 0);
+	return seq_printf(m, "%u\n", (sbi->ll_flags & LL_SBI_CHECKSUM) ? 1 : 0);
 }
 
-static int ll_wr_checksum(struct file *file, const char *buffer,
-                          unsigned long count, void *data)
+static ssize_t ll_checksum_seq_write(struct file *file, const char *buffer,
+				     size_t count, loff_t *off)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
+	struct seq_file *m = file->private_data;
+	struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);
         int val, rc;
 
         if (!sbi->ll_dt_exp)
@@ -549,19 +526,20 @@ static int ll_wr_checksum(struct file *file, const char *buffer,
 
         return count;
 }
+LPROC_SEQ_FOPS(ll_checksum);
 
-static int ll_rd_max_rw_chunk(char *page, char **start, off_t off,
-                          int count, int *eof, void *data)
+static int ll_max_rw_chunk_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = data;
+	struct super_block *sb = m->private;
 
-        return snprintf(page, count, "%lu\n", ll_s2sbi(sb)->ll_max_rw_chunk);
+	return seq_printf(m, "%lu\n", ll_s2sbi(sb)->ll_max_rw_chunk);
 }
 
-static int ll_wr_max_rw_chunk(struct file *file, const char *buffer,
-                          unsigned long count, void *data)
+static ssize_t ll_max_rw_chunk_seq_write(struct file *file, const char *buffer,
+					 size_t count, loff_t *off)
 {
-        struct super_block *sb = data;
+	struct seq_file *m = file->private_data;
+	struct super_block *sb = m->private;
         int rc, val;
 
         rc = lprocfs_write_helper(buffer, count, &val);
@@ -570,27 +548,26 @@ static int ll_wr_max_rw_chunk(struct file *file, const char *buffer,
         ll_s2sbi(sb)->ll_max_rw_chunk = val;
         return count;
 }
+LPROC_SEQ_FOPS(ll_max_rw_chunk);
 
-static int ll_rd_track_id(char *page, int count, void *data,
-                          enum stats_track_type type)
+static int ll_rd_track_id(struct seq_file *m, enum stats_track_type type)
 {
-        struct super_block *sb = data;
-
-        if (ll_s2sbi(sb)->ll_stats_track_type == type) {
-                return snprintf(page, count, "%d\n",
-                                ll_s2sbi(sb)->ll_stats_track_id);
+	struct super_block *sb = m->private;
 
-        } else if (ll_s2sbi(sb)->ll_stats_track_type == STATS_TRACK_ALL) {
-                return snprintf(page, count, "0 (all)\n");
-        } else {
-                return snprintf(page, count, "untracked\n");
-        }
+	if (ll_s2sbi(sb)->ll_stats_track_type == type) {
+		return seq_printf(m, "%d\n",
+				  ll_s2sbi(sb)->ll_stats_track_id);
+	} else if (ll_s2sbi(sb)->ll_stats_track_type == STATS_TRACK_ALL) {
+		return seq_printf(m, "0 (all)\n");
+	} else {
+		return seq_printf(m, "untracked\n");
+	}
 }
 
 static int ll_wr_track_id(const char *buffer, unsigned long count, void *data,
-                          enum stats_track_type type)
+			  enum stats_track_type type)
 {
-        struct super_block *sb = data;
+	struct super_block *sb = data;
         int rc, pid;
 
         rc = lprocfs_write_helper(buffer, count, &pid);
@@ -605,57 +582,59 @@ static int ll_wr_track_id(const char *buffer, unsigned long count, void *data,
         return count;
 }
 
-static int ll_rd_track_pid(char *page, char **start, off_t off,
-                          int count, int *eof, void *data)
+static int ll_track_pid_seq_show(struct seq_file *m, void *v)
 {
-        return (ll_rd_track_id(page, count, data, STATS_TRACK_PID));
+	return ll_rd_track_id(m, STATS_TRACK_PID);
 }
 
-static int ll_wr_track_pid(struct file *file, const char *buffer,
-                          unsigned long count, void *data)
+static ssize_t ll_track_pid_seq_write(struct file *file, const char *buffer,
+				      size_t count, loff_t *off)
 {
-        return (ll_wr_track_id(buffer, count, data, STATS_TRACK_PID));
+	struct seq_file *seq = file->private_data;
+	return ll_wr_track_id(buffer, count, seq->private, STATS_TRACK_PID);
 }
+LPROC_SEQ_FOPS(ll_track_pid);
 
-static int ll_rd_track_ppid(char *page, char **start, off_t off,
-                          int count, int *eof, void *data)
+static int ll_track_ppid_seq_show(struct seq_file *m, void *v)
 {
-        return (ll_rd_track_id(page, count, data, STATS_TRACK_PPID));
+	return ll_rd_track_id(m, STATS_TRACK_PPID);
 }
 
-static int ll_wr_track_ppid(struct file *file, const char *buffer,
-                          unsigned long count, void *data)
+static ssize_t ll_track_ppid_seq_write(struct file *file, const char *buffer,
+				       size_t count, loff_t *off)
 {
-        return (ll_wr_track_id(buffer, count, data, STATS_TRACK_PPID));
+	struct seq_file *seq = file->private_data;
+	return ll_wr_track_id(buffer, count, seq->private, STATS_TRACK_PPID);
 }
+LPROC_SEQ_FOPS(ll_track_ppid);
 
-static int ll_rd_track_gid(char *page, char **start, off_t off,
-                          int count, int *eof, void *data)
+static int ll_track_gid_seq_show(struct seq_file *m, void *v)
 {
-        return (ll_rd_track_id(page, count, data, STATS_TRACK_GID));
+	return ll_rd_track_id(m, STATS_TRACK_GID);
 }
 
-static int ll_wr_track_gid(struct file *file, const char *buffer,
-                          unsigned long count, void *data)
+static ssize_t ll_track_gid_seq_write(struct file *file, const char *buffer,
+				      size_t count, loff_t *off)
 {
-        return (ll_wr_track_id(buffer, count, data, STATS_TRACK_GID));
+	struct seq_file *seq = file->private_data;
+	return ll_wr_track_id(buffer, count, seq->private, STATS_TRACK_GID);
 }
+LPROC_SEQ_FOPS(ll_track_gid);
 
-static int ll_rd_statahead_max(char *page, char **start, off_t off,
-                               int count, int *eof, void *data)
+static int ll_statahead_max_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
+	struct super_block *sb = m->private;
+	struct ll_sb_info *sbi = ll_s2sbi(sb);
 
-        return snprintf(page, count, "%u\n", sbi->ll_sa_max);
+	return seq_printf(m, "%u\n", sbi->ll_sa_max);
 }
 
-static int ll_wr_statahead_max(struct file *file, const char *buffer,
-                               unsigned long count, void *data)
+static ssize_t ll_statahead_max_seq_write(struct file *file, const char *buffer,
+					  size_t count, loff_t *off)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
-        int val, rc;
+	struct seq_file *m = file->private_data;
+	struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);
+	int val, rc;
 
         rc = lprocfs_write_helper(buffer, count, &val);
         if (rc)
@@ -669,23 +648,23 @@ static int ll_wr_statahead_max(struct file *file, const char *buffer,
 
         return count;
 }
+LPROC_SEQ_FOPS(ll_statahead_max);
 
-static int ll_rd_statahead_agl(char *page, char **start, off_t off,
-                               int count, int *eof, void *data)
+static int ll_statahead_agl_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
+	struct super_block *sb = m->private;
+	struct ll_sb_info *sbi = ll_s2sbi(sb);
 
-        return snprintf(page, count, "%u\n",
-                        sbi->ll_flags & LL_SBI_AGL_ENABLED ? 1 : 0);
+	return seq_printf(m, "%u\n",
+			  sbi->ll_flags & LL_SBI_AGL_ENABLED ? 1 : 0);
 }
 
-static int ll_wr_statahead_agl(struct file *file, const char *buffer,
-                               unsigned long count, void *data)
+static ssize_t ll_statahead_agl_seq_write(struct file *file, const char *buffer,
+					  size_t count, loff_t *off)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
-        int val, rc;
+	struct seq_file *m = file->private_data;
+	struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);
+	int val, rc;
 
         rc = lprocfs_write_helper(buffer, count, &val);
         if (rc)
@@ -698,14 +677,14 @@ static int ll_wr_statahead_agl(struct file *file, const char *buffer,
 
         return count;
 }
+LPROC_SEQ_FOPS(ll_statahead_agl);
 
-static int ll_rd_statahead_stats(char *page, char **start, off_t off,
-                                 int count, int *eof, void *data)
+static int ll_statahead_stats_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
+	struct super_block *sb = m->private;
+	struct ll_sb_info *sbi = ll_s2sbi(sb);
 
-        return snprintf(page, count,
+	return seq_printf(m,
                         "statahead total: %u\n"
                         "statahead wrong: %u\n"
                         "agl total: %u\n",
@@ -713,23 +692,23 @@ static int ll_rd_statahead_stats(char *page, char **start, off_t off,
                         atomic_read(&sbi->ll_sa_wrong),
                         atomic_read(&sbi->ll_agl_total));
 }
+LPROC_SEQ_FOPS_RO(ll_statahead_stats);
 
-static int ll_rd_lazystatfs(char *page, char **start, off_t off,
-                            int count, int *eof, void *data)
+static int ll_lazystatfs_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
+	struct super_block *sb = m->private;
+	struct ll_sb_info *sbi = ll_s2sbi(sb);
 
-        return snprintf(page, count, "%u\n",
-                        (sbi->ll_flags & LL_SBI_LAZYSTATFS) ? 1 : 0);
+	return seq_printf(m, "%u\n",
+			  (sbi->ll_flags & LL_SBI_LAZYSTATFS) ? 1 : 0);
 }
 
-static int ll_wr_lazystatfs(struct file *file, const char *buffer,
-                            unsigned long count, void *data)
+static ssize_t ll_lazystatfs_seq_write(struct file *file, const char *buffer,
+					size_t count, loff_t *off)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
-        int val, rc;
+	struct seq_file *m = file->private_data;
+	struct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);
+	int val, rc;
 
         rc = lprocfs_write_helper(buffer, count, &val);
         if (rc)
@@ -742,30 +721,29 @@ static int ll_wr_lazystatfs(struct file *file, const char *buffer,
 
         return count;
 }
+LPROC_SEQ_FOPS(ll_lazystatfs);
 
-static int ll_rd_maxea_size(char *page, char **start, off_t off,
-                            int count, int *eof, void *data)
+static int ll_maxea_size_seq_show(struct seq_file *m, void *v)
 {
-        struct super_block *sb = data;
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
-        unsigned int ealen;
-        int rc;
+	struct super_block *sb = m->private;
+	struct ll_sb_info *sbi = ll_s2sbi(sb);
+	unsigned int ealen;
+	int rc;
 
         rc = ll_get_max_mdsize(sbi, &ealen);
         if (rc)
                 return rc;
 
-        return snprintf(page, count, "%u\n", ealen);
+	return seq_printf(m, "%u\n", ealen);
 }
+LPROC_SEQ_FOPS_RO(ll_maxea_size);
 
-static int ll_rd_sbi_flags(char *page, char **start, off_t off,
-				int count, int *eof, void *data)
+static int ll_sbi_flags_seq_show(struct seq_file *m, void *v)
 {
 	const char *str[] = LL_SBI_FLAGS;
-	struct super_block *sb = data;
+	struct super_block *sb = m->private;
 	int flags = ll_s2sbi(sb)->ll_flags;
 	int i = 0;
-	int rc = 0;
 
 	while (flags != 0) {
 		if (ARRAY_SIZE(str) <= i) {
@@ -775,66 +753,86 @@ static int ll_rd_sbi_flags(char *page, char **start, off_t off,
 		}
 
 		if (flags & 0x1)
-			rc += snprintf(page + rc, count - rc, "%s ", str[i]);
+			seq_printf(m, "%s ", str[i]);
 		flags >>= 1;
 		++i;
 	}
-	if (rc > 0)
-		rc += snprintf(page + rc, count - rc, "\b\n");
-	return rc;
+	seq_printf(m, "\b\n");
+	return 0;
 }
+LPROC_SEQ_FOPS_RO(ll_sbi_flags);
 
-static int ll_rd_unstable_stats(char *page, char **start, off_t off,
-			      int count, int *eof, void *data)
+static int ll_unstable_stats_seq_show(struct seq_file *m, void *v)
 {
-	struct super_block	*sb    = data;
+	struct super_block	*sb    = m->private;
 	struct ll_sb_info	*sbi   = ll_s2sbi(sb);
 	struct cl_client_cache	*cache = &sbi->ll_cache;
-	int pages, mb, rc;
+	int pages, mb;
 
 	pages = cfs_atomic_read(&cache->ccc_unstable_nr);
 	mb    = (pages * PAGE_CACHE_SIZE) >> 20;
 
-	rc = snprintf(page, count, "unstable_pages: %8d\n"
-				   "unstable_mb:    %8d\n", pages, mb);
-
-	return rc;
+	return seq_printf(m, "unstable_pages: %8d\n"
+				"unstable_mb:    %8d\n", pages, mb);
 }
-
-static struct lprocfs_vars lprocfs_llite_obd_vars[] = {
-        { "uuid",         ll_rd_sb_uuid,          0, 0 },
-        //{ "mntpt_path",   ll_rd_path,             0, 0 },
-        { "fstype",       ll_rd_fstype,           0, 0 },
-        { "site",         ll_rd_site_stats,       0, 0 },
-        { "blocksize",    ll_rd_blksize,          0, 0 },
-        { "kbytestotal",  ll_rd_kbytestotal,      0, 0 },
-        { "kbytesfree",   ll_rd_kbytesfree,       0, 0 },
-        { "kbytesavail",  ll_rd_kbytesavail,      0, 0 },
-        { "filestotal",   ll_rd_filestotal,       0, 0 },
-        { "filesfree",    ll_rd_filesfree,        0, 0 },
-        { "client_type",  ll_rd_client_type,      0, 0 },
-        //{ "filegroups",   lprocfs_rd_filegroups,  0, 0 },
-        { "max_read_ahead_mb", ll_rd_max_readahead_mb,
-                               ll_wr_max_readahead_mb, 0 },
-        { "max_read_ahead_per_file_mb", ll_rd_max_readahead_per_file_mb,
-                                        ll_wr_max_readahead_per_file_mb, 0 },
-        { "max_read_ahead_whole_mb", ll_rd_max_read_ahead_whole_mb,
-                                     ll_wr_max_read_ahead_whole_mb, 0 },
-        { "max_cached_mb",    ll_rd_max_cached_mb, ll_wr_max_cached_mb, 0 },
-        { "checksum_pages",   ll_rd_checksum, ll_wr_checksum, 0 },
-        { "max_rw_chunk",     ll_rd_max_rw_chunk, ll_wr_max_rw_chunk, 0 },
-        { "stats_track_pid",  ll_rd_track_pid, ll_wr_track_pid, 0 },
-        { "stats_track_ppid", ll_rd_track_ppid, ll_wr_track_ppid, 0 },
-        { "stats_track_gid",  ll_rd_track_gid, ll_wr_track_gid, 0 },
-        { "statahead_max",    ll_rd_statahead_max, ll_wr_statahead_max, 0 },
-        { "statahead_agl",    ll_rd_statahead_agl, ll_wr_statahead_agl, 0 },
-        { "statahead_stats",  ll_rd_statahead_stats, 0, 0 },
-        { "lazystatfs",       ll_rd_lazystatfs, ll_wr_lazystatfs, 0 },
-        { "max_easize",       ll_rd_maxea_size, 0, 0 },
-	{ "sbi_flags",        ll_rd_sbi_flags, 0, 0 },
-	{ "xattr_cache",      ll_rd_xattr_cache, ll_wr_xattr_cache, 0 },
-	{ "unstable_stats",   ll_rd_unstable_stats, 0, 0},
-        { 0 }
+LPROC_SEQ_FOPS_RO(ll_unstable_stats);
+
+static struct lprocfs_seq_vars lprocfs_llite_obd_vars[] = {
+	{ .name	=	"uuid",
+	  .fops	=	&ll_sb_uuid_fops			},
+	{ .name	=	"fstype",
+	  .fops	=	&ll_fstype_fops				},
+	{ .name	=	"site",
+	  .fops	=	&ll_site_stats_fops			},
+	{ .name	=	"blocksize",
+	  .fops	=	&ll_blksize_fops			},
+	{ .name	=	"kbytestotal",
+	  .fops =	&ll_kbytestotal_fops			},
+	{ .name	=	"kbytesfree",
+	  .fops	=	&ll_kbytesfree_fops			},
+	{ .name	=	"kbytesavail",
+	  .fops	=	&ll_kbytesavail_fops			},
+	{ .name	=	"filestotal",
+	  .fops	=	&ll_filestotal_fops			},
+	{ .name	=	"filesfree",
+	  .fops	=	&ll_filesfree_fops			},
+	{ .name	=	"client_type",
+	  .fops	=	&ll_client_type_fops			},
+	{ .name	=	"max_read_ahead_mb",
+	  .fops	=	&ll_max_readahead_mb_fops		},
+	{ .name	=	"max_read_ahead_per_file_mb",
+	  .fops	=	&ll_max_readahead_per_file_mb_fops	},
+	{ .name	=	"max_read_ahead_whole_mb",
+	  .fops	=	&ll_max_read_ahead_whole_mb_fops	},
+	{ .name	=	"max_cached_mb",
+	  .fops	=	&ll_max_cached_mb_fops			},
+	{ .name	=	"checksum_pages",
+	  .fops	=	&ll_checksum_fops			},
+	{ .name	=	"max_rw_chunk",
+	  .fops	=	&ll_max_rw_chunk_fops			},
+	{ .name	=	"stats_track_pid",
+	  .fops	=	&ll_track_pid_fops			},
+	{ .name	=	"stats_track_ppid",
+	  .fops	=	&ll_track_ppid_fops			},
+	{ .name	=	"stats_track_gid",
+	  .fops	=	&ll_track_gid_fops			},
+	{ .name	=	"statahead_max",
+	  .fops	=	&ll_statahead_max_fops			},
+	{ .name	=	"statahead_agl",
+	  .fops	=	&ll_statahead_agl_fops			},
+	{ .name	=	"statahead_stats",
+	  .fops	=	&ll_statahead_stats_fops		},
+	{ .name	=	"lazystatfs",
+	  .fops =	&ll_lazystatfs_fops			},
+	{ .name	=	"max_easize",
+	  .fops =	&ll_maxea_size_fops			},
+	{ .name	=	"sbi_flags",
+	  .fops =	&ll_sbi_flags_fops			},
+	{ .name	=	"xattr_cache",
+	  .fops	=	&ll_xattr_cache_fops			},
+	{ .name	=	"unstable_stats",
+	  .fops	=	&ll_unstable_stats_fops			},
+	{ 0 }
 };
 
 #define MAX_STRING_SIZE 128
@@ -924,14 +922,17 @@ static const char *ra_stat_string[] = {
         [RA_STAT_WRONG_GRAB_PAGE] = "wrong page from grab_cache_page",
 };
 
+LPROC_SEQ_FOPS_RO_TYPE(llite, name);
+LPROC_SEQ_FOPS_RO_TYPE(llite, uuid);
 
 int lprocfs_register_mountpoint(struct proc_dir_entry *parent,
                                 struct super_block *sb, char *osc, char *mdc)
 {
-        struct lprocfs_vars lvars[2];
+	struct lprocfs_seq_vars lvars[2];
         struct lustre_sb_info *lsi = s2lsi(sb);
         struct ll_sb_info *sbi = ll_s2sbi(sb);
         struct obd_device *obd;
+	struct proc_dir_entry *dir;
         char name[MAX_STRING_SIZE + 1], *ptr;
         int err, id, len, rc;
         ENTRY;
@@ -955,7 +956,7 @@ int lprocfs_register_mountpoint(struct proc_dir_entry *parent,
         snprintf(name, MAX_STRING_SIZE, "%.*s-%p", len,
                  lsi->lsi_lmd->lmd_profile, sb);
 
-        sbi->ll_proc_root = lprocfs_register(name, parent, NULL, NULL);
+	sbi->ll_proc_root = lprocfs_seq_register(name, parent, NULL, NULL);
         if (IS_ERR(sbi->ll_proc_root)) {
                 err = PTR_ERR(sbi->ll_proc_root);
                 sbi->ll_proc_root = NULL;
@@ -1020,7 +1021,7 @@ int lprocfs_register_mountpoint(struct proc_dir_entry *parent,
                 GOTO(out, err);
 
 
-        err = lprocfs_add_vars(sbi->ll_proc_root, lprocfs_llite_obd_vars, sb);
+	err = lprocfs_seq_add_vars(sbi->ll_proc_root, lprocfs_llite_obd_vars, sb);
         if (err)
                 GOTO(out, err);
 
@@ -1031,18 +1032,21 @@ int lprocfs_register_mountpoint(struct proc_dir_entry *parent,
         LASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);
         LASSERT(obd->obd_type->typ_name != NULL);
 
-        snprintf(name, MAX_STRING_SIZE, "%s/common_name",
-                 obd->obd_type->typ_name);
-        lvars[0].read_fptr = lprocfs_rd_name;
-        err = lprocfs_add_vars(sbi->ll_proc_root, lvars, obd);
-        if (err)
-                GOTO(out, err);
+	dir = proc_mkdir(obd->obd_type->typ_name, sbi->ll_proc_root);
+	if (dir == NULL)
+		GOTO(out, err = -ENOMEM);
 
-        snprintf(name, MAX_STRING_SIZE, "%s/uuid", obd->obd_type->typ_name);
-        lvars[0].read_fptr = lprocfs_rd_uuid;
-        err = lprocfs_add_vars(sbi->ll_proc_root, lvars, obd);
-        if (err)
-                GOTO(out, err);
+	snprintf(name, MAX_STRING_SIZE, "common_name");
+	lvars[0].fops = &llite_name_fops;
+	err = lprocfs_seq_add_vars(dir, lvars, obd);
+	if (err)
+		GOTO(out, err);
+
+	snprintf(name, MAX_STRING_SIZE, "uuid");
+	lvars[0].fops = &llite_uuid_fops;
+	err = lprocfs_seq_add_vars(dir, lvars, obd);
+	if (err)
+		GOTO(out, err);
 
         /* OSC */
         obd = class_name2obd(osc);
@@ -1051,16 +1055,19 @@ int lprocfs_register_mountpoint(struct proc_dir_entry *parent,
         LASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);
         LASSERT(obd->obd_type->typ_name != NULL);
 
-        snprintf(name, MAX_STRING_SIZE, "%s/common_name",
-                 obd->obd_type->typ_name);
-        lvars[0].read_fptr = lprocfs_rd_name;
-        err = lprocfs_add_vars(sbi->ll_proc_root, lvars, obd);
-        if (err)
-                GOTO(out, err);
+	dir = proc_mkdir(obd->obd_type->typ_name, sbi->ll_proc_root);
+	if (dir == NULL)
+		GOTO(out, err = -ENOMEM);
+
+	snprintf(name, MAX_STRING_SIZE, "common_name");
+	lvars[0].fops = &llite_name_fops;
+	err = lprocfs_seq_add_vars(dir, lvars, obd);
+	if (err)
+		GOTO(out, err);
 
-        snprintf(name, MAX_STRING_SIZE, "%s/uuid", obd->obd_type->typ_name);
-        lvars[0].read_fptr = lprocfs_rd_uuid;
-        err = lprocfs_add_vars(sbi->ll_proc_root, lvars, obd);
+	snprintf(name, MAX_STRING_SIZE, "uuid");
+	lvars[0].fops = &llite_uuid_fops;
+	err = lprocfs_seq_add_vars(dir, lvars, obd);
 out:
         if (err) {
                 lprocfs_remove(&sbi->ll_proc_root);
@@ -1439,9 +1446,11 @@ static ssize_t ll_rw_offset_stats_seq_write(struct file *file, const char *buf,
 
 LPROC_SEQ_FOPS(ll_rw_offset_stats);
 
-void lprocfs_llite_init_vars(struct lprocfs_static_vars *lvars)
+int ll_process_proc_param(struct lustre_cfg *lcfg, unsigned long *sb)
 {
-    lvars->module_vars  = NULL;
-    lvars->obd_vars     = lprocfs_llite_obd_vars;
+	int rc = class_process_proc_seq_param(PARAM_LLITE,
+					      lprocfs_llite_obd_vars,
+					      lcfg, (void *)sb);
+	return (rc > 0 ? 0 : rc);
 }
 #endif /* LPROCFS */
diff --git a/lustre/llite/super25.c b/lustre/llite/super25.c
index 06b55fe..4692f6e 100644
--- a/lustre/llite/super25.c
+++ b/lustre/llite/super25.c
@@ -169,7 +169,7 @@ static int __init init_lustre_lite(void)
 	}
 
         proc_lustre_fs_root = proc_lustre_root ?
-                              lprocfs_register("llite", proc_lustre_root, NULL, NULL) : NULL;
+			      lprocfs_seq_register("llite", proc_lustre_root, NULL, NULL) : NULL;
 
         lustre_register_client_fill_super(ll_fill_super);
         lustre_register_kill_super_cb(ll_kill_super);
diff --git a/lustre/llite/vvp_dev.c b/lustre/llite/vvp_dev.c
index 2fdb613..fa124e2 100644
--- a/lustre/llite/vvp_dev.c
+++ b/lustre/llite/vvp_dev.c
@@ -530,10 +530,9 @@ static struct seq_operations vvp_pgcache_ops = {
 
 static int vvp_dump_pgcache_seq_open(struct inode *inode, struct file *filp)
 {
-        struct proc_dir_entry *dp  = PDE(inode);
-        struct ll_sb_info     *sbi = dp->data;
-        struct seq_file       *seq;
-        int                    result;
+	struct ll_sb_info	*sbi = PDE_DATA(inode);
+	struct seq_file		*seq;
+	int			result;
 
         result = seq_open(filp, &vvp_pgcache_ops);
         if (result == 0) {
diff --git a/lustre/obdclass/cl_object.c b/lustre/obdclass/cl_object.c
index 1984836..985cf0b 100644
--- a/lustre/obdclass/cl_object.c
+++ b/lustre/obdclass/cl_object.c
@@ -400,11 +400,10 @@ void cache_stats_init(struct cache_stats *cs, const char *name)
 		cfs_atomic_set(&cs->cs_stats[i], 0);
 }
 
-int cache_stats_print(const struct cache_stats *cs,
-                      char *page, int count, int h)
+int cache_stats_print(const struct cache_stats *cs, struct seq_file *m, int h)
 {
-	int nob = 0;
 	int i;
+
 	/*
 	 *   lookup    hit    total  cached create
 	 * env: ...... ...... ...... ...... ......
@@ -412,18 +411,16 @@ int cache_stats_print(const struct cache_stats *cs,
 	if (h) {
 		const char *names[CS_NR] = CS_NAMES;
 
-		nob += snprintf(page + nob, count - nob, "%6s", " ");
+		seq_printf(m, "%6s", " ");
 		for (i = 0; i < CS_NR; i++)
-			nob += snprintf(page + nob, count - nob,
-					"%8s", names[i]);
-		nob += snprintf(page + nob, count - nob, "\n");
+			seq_printf(m, "%8s", names[i]);
+		seq_printf(m, "\n");
 	}
 
-	nob += snprintf(page + nob, count - nob, "%5.5s:", cs->cs_name);
+	seq_printf(m, "%5.5s:", cs->cs_name);
 	for (i = 0; i < CS_NR; i++)
-		nob += snprintf(page + nob, count - nob, "%8u",
-				cfs_atomic_read(&cs->cs_stats[i]));
-	return nob;
+		seq_printf(m, "%8u", cfs_atomic_read(&cs->cs_stats[i]));
+	return 0;
 }
 
 static void cl_env_percpu_refill(void);
@@ -471,50 +468,48 @@ static struct cache_stats cl_env_stats = {
  * Outputs client site statistical counters into a buffer. Suitable for
  * ll_rd_*()-style functions.
  */
-int cl_site_stats_print(const struct cl_site *site, char *page, int count)
-{
-        int nob;
-        int i;
-        static const char *pstate[] = {
-                [CPS_CACHED]  = "c",
-                [CPS_OWNED]   = "o",
-                [CPS_PAGEOUT] = "w",
-                [CPS_PAGEIN]  = "r",
-                [CPS_FREEING] = "f"
-        };
-        static const char *lstate[] = {
-                [CLS_NEW]       = "n",
-                [CLS_QUEUING]   = "q",
-                [CLS_ENQUEUED]  = "e",
-                [CLS_HELD]      = "h",
-                [CLS_INTRANSIT] = "t",
-                [CLS_CACHED]    = "c",
-                [CLS_FREEING]   = "f"
-        };
+int cl_site_stats_print(const struct cl_site *site, struct seq_file *m)
+{
+	static const char *pstate[] = {
+		[CPS_CACHED]  = "c",
+		[CPS_OWNED]   = "o",
+		[CPS_PAGEOUT] = "w",
+		[CPS_PAGEIN]  = "r",
+		[CPS_FREEING] = "f"
+	};
+	static const char *lstate[] = {
+		[CLS_NEW]       = "n",
+		[CLS_QUEUING]   = "q",
+		[CLS_ENQUEUED]  = "e",
+		[CLS_HELD]      = "h",
+		[CLS_INTRANSIT] = "t",
+		[CLS_CACHED]    = "c",
+		[CLS_FREEING]   = "f"
+	};
+	int i;
+
 /*
        lookup    hit  total   busy create
 pages: ...... ...... ...... ...... ...... [...... ...... ...... ......]
 locks: ...... ...... ...... ...... ...... [...... ...... ...... ...... ......]
   env: ...... ...... ...... ...... ......
  */
-        nob = lu_site_stats_print(&site->cs_lu, page, count);
-        nob += cache_stats_print(&site->cs_pages, page + nob, count - nob, 1);
-        nob += snprintf(page + nob, count - nob, " [");
-        for (i = 0; i < ARRAY_SIZE(site->cs_pages_state); ++i)
-                nob += snprintf(page + nob, count - nob, "%s: %u ",
-                                pstate[i],
-                                cfs_atomic_read(&site->cs_pages_state[i]));
-        nob += snprintf(page + nob, count - nob, "]\n");
-        nob += cache_stats_print(&site->cs_locks, page + nob, count - nob, 0);
-        nob += snprintf(page + nob, count - nob, " [");
-        for (i = 0; i < ARRAY_SIZE(site->cs_locks_state); ++i)
-                nob += snprintf(page + nob, count - nob, "%s: %u ",
-                                lstate[i],
-                                cfs_atomic_read(&site->cs_locks_state[i]));
-        nob += snprintf(page + nob, count - nob, "]\n");
-        nob += cache_stats_print(&cl_env_stats, page + nob, count - nob, 0);
-        nob += snprintf(page + nob, count - nob, "\n");
-        return nob;
+	lu_site_stats_seq_print(&site->cs_lu, m);
+	cache_stats_print(&site->cs_pages, m, 1);
+	seq_printf(m, " [");
+	for (i = 0; i < ARRAY_SIZE(site->cs_pages_state); ++i)
+		seq_printf(m, "%s: %u ", pstate[i],
+			   cfs_atomic_read(&site->cs_pages_state[i]));
+	seq_printf(m, "]\n");
+	cache_stats_print(&site->cs_locks, m, 0);
+	seq_printf(m, " [");
+	for (i = 0; i < ARRAY_SIZE(site->cs_locks_state); ++i)
+		seq_printf(m, "%s: %u ", lstate[i],
+			   cfs_atomic_read(&site->cs_locks_state[i]));
+	seq_printf(m, "]\n");
+	cache_stats_print(&cl_env_stats, m, 0);
+	seq_printf(m, "\n");
+	return 0;
 }
 EXPORT_SYMBOL(cl_site_stats_print);
 
diff --git a/lustre/obdclass/lu_object.c b/lustre/obdclass/lu_object.c
index 28a18ef..cca2ec0 100644
--- a/lustre/obdclass/lu_object.c
+++ b/lustre/obdclass/lu_object.c
@@ -2090,6 +2090,28 @@ static __u32 ls_stats_read(struct lprocfs_stats *stats, int idx)
  * Output site statistical counters into a buffer. Suitable for
  * lprocfs_rd_*()-style functions.
  */
+int lu_site_stats_seq_print(const struct lu_site *s, struct seq_file *m)
+{
+	lu_site_stats_t stats;
+
+	memset(&stats, 0, sizeof(stats));
+	lu_site_stats_get(s->ls_obj_hash, &stats, 1);
+
+	return seq_printf(m, "%d/%d %d/%d %d %d %d %d %d %d %d\n",
+			  stats.lss_busy,
+			  stats.lss_total,
+			  stats.lss_populated,
+			  CFS_HASH_NHLIST(s->ls_obj_hash),
+			  stats.lss_max_search,
+			  ls_stats_read(s->ls_stats, LU_SS_CREATED),
+			  ls_stats_read(s->ls_stats, LU_SS_CACHE_HIT),
+			  ls_stats_read(s->ls_stats, LU_SS_CACHE_MISS),
+			  ls_stats_read(s->ls_stats, LU_SS_CACHE_RACE),
+			  ls_stats_read(s->ls_stats, LU_SS_CACHE_DEATH_RACE),
+			  ls_stats_read(s->ls_stats, LU_SS_LRU_PURGED));
+}
+EXPORT_SYMBOL(lu_site_stats_seq_print);
+
 int lu_site_stats_print(const struct lu_site *s, char *page, int count)
 {
         lu_site_stats_t stats;
-- 
1.8.5.1

